// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as ReactKonva from "react-konva";
import * as Core__Option from "@rescript/core/src/Core__Option_res.js";
import * as JsxRuntime from "react/jsx-runtime";

var KonvaTarget = {};

var Circle = {};

var Shape = {};

function calculateControlPoints(figure) {
  var x1Float = figure.x1;
  var y1Float = figure.y1;
  return [
          {
            x: x1Float * 0.95 | 0,
            y: (figure.y1 + figure.y2 | 0) / 2 | 0,
            id: 1
          },
          {
            x: (figure.x1 + figure.x2 | 0) / 2 | 0,
            y: y1Float * 0.9 | 0,
            id: 2
          },
          {
            x: figure.x2 * 1.05 | 0,
            y: (figure.y2 + figure.y1 | 0) / 2 | 0,
            id: 3
          },
          {
            x: (figure.x1 + figure.x2 | 0) / 2 | 0,
            y: figure.y2 * 1.05 | 0,
            id: 4
          }
        ];
}

function ManualContour(props) {
  var onChangeFigure = props.onChangeFigure;
  var figure = props.figure;
  React.useRef();
  React.useRef();
  var match = React.useState(function () {
        return [
                {
                  x: figure.x1,
                  y: figure.y1,
                  id: 1
                },
                {
                  x: figure.x2,
                  y: figure.y1,
                  id: 2
                },
                {
                  x: figure.x2,
                  y: figure.y2,
                  id: 3
                },
                {
                  x: figure.x1,
                  y: figure.y2,
                  id: 4
                }
              ];
      });
  var setAnchors = match[1];
  var anchors = match[0];
  var match$1 = React.useState(function () {
        return calculateControlPoints(figure);
      });
  var setControlPoints = match$1[1];
  var controlPoints = match$1[0];
  var anchorElements = anchors.map(function (point) {
        return JsxRuntime.jsx(ReactKonva.Circle, {
                    draggable: true,
                    x: point.x,
                    y: point.y,
                    radius: 25,
                    stroke: "#666",
                    fill: "#ddd",
                    onDragMove: (function (konvaEvent) {
                        setAnchors(function (points) {
                              return points.map(function (currentPoint) {
                                          if (point.id === currentPoint.id) {
                                            return {
                                                    x: konvaEvent.target.x(),
                                                    y: konvaEvent.target.y(),
                                                    id: currentPoint.id
                                                  };
                                          } else {
                                            return currentPoint;
                                          }
                                        });
                            });
                        onChangeFigure(figure.id, {
                              page_id: figure.page_id,
                              y1: figure.y1,
                              y2: figure.y2,
                              x1: figure.x1,
                              x2: figure.x2,
                              id: figure.id,
                              typeName: figure.typeName,
                              controlPoints: controlPoints,
                              anchors: anchors,
                              manual_bounding_box: figure.manual_bounding_box
                            });
                      })
                  });
      });
  var controlPointElements = controlPoints.map(function (point, index) {
        return JsxRuntime.jsx(ReactKonva.Circle, {
                    draggable: true,
                    x: point.x,
                    y: point.y,
                    radius: 25,
                    stroke: "#666",
                    fill: "#ddd",
                    onDragMove: (function (konvaEvent) {
                        setControlPoints(function (points) {
                              return points.map(function (currentPoint) {
                                          if (point.id === currentPoint.id) {
                                            return {
                                                    x: konvaEvent.target.x(),
                                                    y: konvaEvent.target.y(),
                                                    id: currentPoint.id
                                                  };
                                          } else {
                                            return currentPoint;
                                          }
                                        });
                            });
                        onChangeFigure(figure.id, {
                              page_id: figure.page_id,
                              y1: figure.y1,
                              y2: figure.y2,
                              x1: figure.x1,
                              x2: figure.x2,
                              id: figure.id,
                              typeName: figure.typeName,
                              controlPoints: controlPoints,
                              anchors: anchors,
                              manual_bounding_box: figure.manual_bounding_box
                            });
                      })
                  }, String(index));
      });
  return JsxRuntime.jsxs(React.Fragment, {
              children: [
                JsxRuntime.jsx(ReactKonva.Shape, {
                      sceneFunc: (function (konvaContext, shape) {
                          konvaContext.beginPath();
                          var start = anchors[0];
                          if (start !== undefined) {
                            konvaContext.moveTo(start.x, start.y);
                          } else {
                            console.log("point is null");
                          }
                          for(var index = 1; index <= 3; ++index){
                            Core__Option.forEach(anchors[index], (function(index){
                                return function (anchor) {
                                  Core__Option.forEach(controlPoints[index], (function (controlPoint) {
                                          konvaContext.quadraticCurveTo(controlPoint.x, controlPoint.y, anchor.x, anchor.y);
                                        }));
                                }
                                }(index)));
                          }
                          var firstControlPoint = controlPoints[0];
                          var firstAnchor = anchors[0];
                          konvaContext.quadraticCurveTo(firstControlPoint.x, firstControlPoint.y, firstAnchor.x, firstAnchor.y);
                          konvaContext.fillStrokeShape(shape);
                        }),
                      strokeWidth: 4,
                      stroke: "red"
                    }),
                anchorElements,
                controlPointElements
              ]
            });
}

var make = ManualContour;

var $$default = ManualContour;

export {
  KonvaTarget ,
  Circle ,
  Shape ,
  calculateControlPoints ,
  make ,
  $$default as default,
}
/* react Not a pure module */
